#version 450

#extension GL_GOOGLE_include_directive : require
#include "grass_instance.glsl"
#include "terrain_chunk_instance.glsl"
#include "grass_gen.h"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std140, set = 2, binding = 0) uniform uSettings {
    GrassGenerationParams params;
};

layout(std140, set = 2, binding = 1) uniform uTime {
    float time;
};

layout(set = 1, binding = 0) writeonly buffer GrassInstances {
    GrassInstance Grassblades[];
};

layout(set = 1, binding = 1) writeonly buffer ChunkInstances {
    ChunkInstance Chunks[];
};

float rand(float x) {
    return fract(sin(x) * 100000.f);
}

#define FLAG_ON(value) bool(params.flags & value)
const float PI = 3.14159265358979323846;

void main() {

    // Each workgroup processes a single terrain chunk for now
    if (gl_LocalInvocationIndex == 0) {
        int chunk_x = int(gl_WorkGroupID.x) - int(params.terrain_width / 2);
        int chunk_y = int(gl_WorkGroupID.y) - int(params.terrain_width / 2);
        uint chunk_idx = gl_WorkGroupID.x + (gl_WorkGroupID.y * params.terrain_width);
        Chunks[chunk_idx].world_translation = ivec2(chunk_x, chunk_y);
    }

    uint idx = gl_GlobalInvocationID.x + (gl_GlobalInvocationID.y * params.grass_per_chunk * params.terrain_width);
    Grassblades[idx].color = params.base_color.xyz;
    Grassblades[idx].rotation = FLAG_ON(GRASS_ROTATE) ? rand(idx * sin(time)) * PI : 0.f;

    float off_x = 0.f;
    float off_z = 0.f;
    if (FLAG_ON(GRASS_OFFSET_POS)) {
        off_x = mod(rand(sin(time)) * 2 - 1, params.offset_cap);
        off_z = mod(rand(cos(time)) * 2 - 1, params.offset_cap);
    }

    Grassblades[idx].world_pos = vec3((gl_GlobalInvocationID.x / params.density) + off_x,
            0.f, (gl_GlobalInvocationID.y / params.density) + off_z);
}
