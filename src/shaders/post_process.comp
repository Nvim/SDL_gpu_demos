#version 450

#extension GL_GOOGLE_include_directive : require
#include "post_process_flags.h"

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba16) uniform readonly image2D TexHdrIn[];
layout(set = 1, binding = 0, rgba8) uniform writeonly image2D TexSdrOut;

layout(std140, set = 2, binding = 0) uniform uSettings {
    uint flags;
    float pad[3];
};

vec3 tonemap_reinhard(vec3 col);
vec3 tonemap_reinhard_ext(vec3 col);
vec3 tonemap_aces(vec3 col);
vec3 tonemap_hable(vec3 col);
vec3 tonemap_filmic(vec3 col);

vec3 tonemap(vec3 col) {
    uint useNone = (flags & TONEMAP_NONE);
    uint useReinHard = (flags & TONEMAP_REINHARD);
    uint useReinHardExt = (flags & TONEMAP_REINHARD_EXTENDED);
    uint useACES = (flags & TONEMAP_ACES);
    uint useHable = (flags & TONEMAP_HABLE);
    uint useFilmic = (flags & TONEMAP_FILMIC);

    if (useNone != 0u)
        return col;

    if (useReinHard != 0u)
        return tonemap_reinhard(col);

    if (useReinHardExt != 0u)
        return tonemap_reinhard_ext(col);

    if (useACES != 0u)
        return tonemap_aces(col);

    if (useHable != 0u)
        return tonemap_hable(col);

    if (useFilmic != 0u)
        return tonemap_filmic(col);

    return col;
}

void main() {
    vec2 dimensions = imageSize(TexHdrIn[0]);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dimensions;

    vec4 pixel = imageLoad(TexHdrIn[0], ivec2(gl_GlobalInvocationID.xy));
    vec3 result = pixel.rgb;

    // Tone map:
    result = tonemap(result);

    // Gamma correction:
    if (bool(flags & USE_GAMMA_CORRECT)) {
        result = pow(result, vec3(1.0 / 2.2));
    }

    imageStore(TexSdrOut, ivec2(gl_GlobalInvocationID.xy), vec4(result, pixel.a));
}

// REINHARD //
float luminance(vec3 col) {
    return dot(col, vec3(0.2126f, 0.7152f, 0.0722f));
}

vec3 change_luminance(vec3 c_in, float l_out)
{
    float l_in = luminance(c_in);
    return c_in * (l_out / l_in);
}

vec3 tonemap_reinhard(vec3 col) {
    return col / (col + vec3(1.0));
}

vec3 tonemap_reinhard_ext(vec3 col) {
    float l_old = luminance(col);
    float max_white_l = 660.0; // This should be dynamic
    float numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));
    float l_new = numerator / (1.0f + l_old);

    return change_luminance(col, l_new);
    // vec3 numerator = col * (1.0f + (col / vec3(max_white_l * max_white_l)));
    // return numerator / (1.0f + col);
}

// ACES //
// https://github.com/dmnsgn/glsl-tone-map/blob/main/aces.glsl
vec3 tonemap_aces(vec3 x) {
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

// HABLE //
vec3 hable_partial(vec3 x)
{
    float A = 0.15f;
    float B = 0.50f;
    float C = 0.10f;
    float D = 0.20f;
    float E = 0.02f;
    float F = 0.30f;
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

vec3 tonemap_hable(vec3 col)
{
    float exposure_bias = 2.0f;
    vec3 curr = hable_partial(col * exposure_bias);

    vec3 W = vec3(11.2f);
    vec3 white_scale = vec3(1.0f) / hable_partial(W);
    return curr * white_scale;
}

vec3 tonemap_filmic(vec3 col) {
    vec3 X = max(vec3(0.0), col - 0.004);
    vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
    return pow(result, vec3(2.2));
}
