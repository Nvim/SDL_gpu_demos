#version 450

#extension GL_GOOGLE_include_directive : require
#include "grass_instance.glsl"
#include "cull_chunks_settings.h"
#include "terrain_chunk_instance.glsl"
#include "grass_gen.h"
#include "camera_binding.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct IndirectDraw {
    uint num_indices; /**< The number of indices to draw per instance. */
    uint num_instances; /**< The number of instances to draw. */
    uint first_index; /**< The base index within the index buffer. */
    uint vertex_offset; /**< The value added to the vertex index before indexing into the vertex buffer. */
    uint first_instance; /**< The ID of the first instance to draw. */
};

layout(std140, set = 2, binding = 0) uniform uSettings {
    CullChunkSettings params;
};

layout(std140, set = 2, binding = 1) uniform uCamera {
    CameraBinding camera;
};

layout(set = 0, binding = 0) readonly buffer ChunkInstances {
    ChunkInstance Chunks[];
};

layout(set = 1, binding = 0) writeonly buffer VisibleChunkIndices {
    uint VisibleChunks[];
};

layout(set = 1, binding = 1) writeonly buffer VisibleGrassbladesIndices {
    uint VisibleGrassblades[];
};

layout(set = 1, binding = 2) writeonly buffer IndirectDrawsBuffer {
    IndirectDraw IndirectDraws[];
};

// Shamelessly stolen from Vulkan Samples:
// https://github.com/KhronosGroup/Vulkan-Samples/blob/main/samples/performance/multi_draw_indirect/multi_draw_indirect.cpp
bool check_is_visible(mat4 mat, vec3 origin, float radius)
{
    uint plane_index = 0;
    for (uint i = 0; i < 3; ++i)
    {
        for (uint j = 0; j < 2; ++j, ++plane_index)
        {
            if (plane_index == 2 || plane_index == 3)
            {
                continue;
            }
            const float sign = (j > 0) ? 1.f : -1.f;
            vec4 plane = vec4(0, 0, 0, 0);
            for (uint k = 0; k < 4; ++k)
            {
                plane[k] = mat[k][3] + sign * mat[k][i];
            }
            plane.xyzw /= sqrt(dot(plane.xyz, plane.xyz));
            if (dot(origin, plane.xyz) + plane.w + radius < 0)
            {
                return false;
            }
        }
    }
    return true;
}

void main() {
    // Each invocation processes a single chunk
    uint chunk_y = gl_GlobalInvocationID.y;
    uint chunk_x = gl_GlobalInvocationID.x;
    uint chunk_idx = chunk_x + (chunk_y * params.terrain_width);

    if (chunk_idx == 0) {
        IndirectDraws[0].num_instances = 0;
        IndirectDraws[1].num_instances = 0;
    }
    barrier();
    memoryBarrierShared();

    if (chunk_y >= params.terrain_width || chunk_x >= params.terrain_width) {
        return;
    }

    ChunkInstance instance = Chunks[chunk_idx];

    float w = instance.world_translation.x;
    float h = instance.world_translation.y;
    float world_scale = float(params.world_size) / float(params.terrain_width);

    // Chunks are 0.5*0.5 in local space.
    float chunk_radius = world_scale;
    vec3 chunk_translation = vec3(w * world_scale, 0.f, h * world_scale);

    uint total_grassblades = params.grass_per_chunk * params.grass_per_chunk;
    uint grass_per_line = params.grass_per_chunk * params.terrain_width;

    if (check_is_visible(camera.viewproj, chunk_translation, chunk_radius)) {
        uint i = atomicAdd(IndirectDraws[0].num_instances, 1);
        VisibleChunks[i] = chunk_idx;
        uint j = atomicAdd(IndirectDraws[1].num_instances, total_grassblades);
        for (uint k = 0; k < total_grassblades; k++) {
            uint y = k % params.grass_per_chunk;
            uint x = k / params.grass_per_chunk;
            x += (chunk_x * params.grass_per_chunk);
            y += (chunk_y * params.grass_per_chunk);
            VisibleGrassblades[j++] = y * grass_per_line + x;
        }
    }
}
